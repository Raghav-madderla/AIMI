"""
Question Cleaning Agent

Purpose: Refines the question generated by the question gen model to align with
what the orchestrator wants to ask about the specific resume point.
"""

from typing import Dict
from app.services.local_llm_service import local_llm_service


async def question_cleaning_agent(
    generated_question: str,
    resume_point: str,
    orchestrator_intent: str,
    domain: str
) -> Dict:
    """
    Cleans and refines the generated question to match orchestrator's intent
    
    Args:
        generated_question: Question from the question gen model
        resume_point: The specific resume point being discussed
        orchestrator_intent: What the orchestrator wants to ask about
        domain: The technical domain
    
    Returns:
        {
            "cleaned_question": "Refined question text",
            "success": True/False
        }
    """
    
    prompt = f"""You are refining an interview question to make it more contextual and relevant.

Resume Point: {resume_point}

Interviewer's Intent: {orchestrator_intent}

Domain: {domain}

Generated Question: {generated_question}

Refine this question to:
1. Be conversational and natural (like a hiring manager would ask)
2. Reference the resume point when relevant
3. Match the interviewer's intent
4. Stay focused on the domain
5. Be clear and specific

Return ONLY the refined question, nothing else.
"""
    
    try:
        messages = [
                {
                    "role": "system",
                    "content": "You are an expert at refining interview questions to be natural and contextual."
                },
                {
                    "role": "user",
                    "content": prompt
                }
        ]
        
        cleaned_question = local_llm_service.generate(messages, max_new_tokens=200, temperature=0.7)
        
        # Remove quotes if present
        if cleaned_question.startswith('"') and cleaned_question.endswith('"'):
            cleaned_question = cleaned_question[1:-1]
        if cleaned_question.startswith("'") and cleaned_question.endswith("'"):
            cleaned_question = cleaned_question[1:-1]
        
        return {
            "cleaned_question": cleaned_question,
            "success": True
        }
        
    except Exception as e:
        print(f"Question cleaning failed: {str(e)}")
        # Fallback: Return original question
        return {
            "cleaned_question": generated_question,
            "success": False,
            "error": str(e)
        }
